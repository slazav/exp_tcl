#!/usr/bin/tclsh

# current sweeper with stdin/stdout interface

package require Device
package require DeviceRole 1.0
package require ParseOptions 2.0

#############################################################
## Command line options:
set options [list \
{-p -ps_dev1}  ps_dev1  {}       {power supply device}\
{-P -ps_dev2}  ps_dev2  {}       {power supply device - 2nd channel}\
{-d -db_dev}   db_dev   {}       {database device (can be empty)}\
{-n -db_val}   db_val   {}       {database name for numerical values}\
{-a -db_ann}   db_ann   {}       {database name for annatations}\
{-v -max_volt} max_volt {1}      {max voltage, V}\
{-m -max_rate} max_rate {1}      {max rate}\
{-t -min_t_step} min_t_step {0.5} {min t step}\
]

#############################################################

itcl::class SweepController {
  variable dev1 {}; # device driver handler
  variable dev2 {}; # device driver handler -- 2nd chan
  variable rh;      # ramping loop handler
  variable cs1;     # set current - 1st chan
  variable cs2;     # set current - 2nd chan
                    # set and measured current, A


  variable db_dev
  variable db_val
  variable db_ann
  variable max_volt
  variable max_rate
  variable min_t_step

  constructor {opts} {
    #Parse options.
    global options
    parse_options "sweeper" $opts $options

    if {$ps_dev1  == {} } { error "ps_dev1 is empty" }
    set dev1 [DeviceRole $ps_dev1 power_supply]
    $dev1 lock

    if {$ps_dev2 != {}} {
      if {$ps_dev1 == $ps_dev2} {error "same devices for both channels"}
      set dev2 [DeviceRole $ps_dev2 power_supply]
      $dev2 lock
    }

    # Open database if needed
    if {$db_dev != {} } { Device $db_dev }
    set rh {}
    reset
  }

  destructor {
    $dev1 unlock
    if {$dev2 != {}} { $dev2 unlock }
  }

  ######################################

  # set current for both channels (internal)
  method set_curr {ch val} {
    if {$ch == 1} { set cs1 [expr {$val-$cs2}]; $dev1 set_curr $cs1 }\
    else          { set cs2 [expr {$val-$cs1}]; $dev2 set_curr $cs2 }
  }

  # get measured current (sum for both channels)
  method get_mcurr {} {
    set c1 [ $dev1 get_curr ]
    if {$dev2 != {}} {
      set c2 [$dev2 get_curr]
      set c1 [expr {$c1 + $c2}]
    }
    return $c1
  }

  # get previously set current (sum for both channels)
  method get_scurr {} {
    return [expr $cs1+$cs2]
  }

  # voltage (1st channel only)
  method get_volt {} { return [ $dev1 get_volt ]}

  # stat (1st channel only)
  method get_stat {} { return [ $dev1 get_stat ]}


  # Return list of commands which can be run from stdin.
  method list {} {return {list sweep sweep_stop reset get_scurr get_mcurr get_volt get_stat} }

  ######################################
  # stop sweep and reset device
  method reset {} {
    if { $db_dev != {} && $db_val != {} } {
      $db_dev cmd "put $db_ann now reset"
      $db_dev cmd "sync"
    }
    after cancel $rh
    set $rh {}

    $dev1 set_ovp $max_volt
    $dev1 cc_reset
    if {$dev2 != {}} {
      $dev2 set_ovp $max_volt
      $dev2 cc_reset
    }

    set cs1 [ $dev1 get_curr ]
    if {$dev2 != {}} { set cs2 [$dev2 get_curr] } else {set cs2 0}

    return
  }

  ######################################
  # stop sweep
  method sweep_stop {} {
    if {$rh != {} && $db_dev != {} && $db_val != {} } {
      $db_dev cmd "put $db_ann now sweep_stop"
      $db_dev cmd "sync"
    }
    after cancel $rh
    return
  }

  ######################################
  method sweep {dest rate {first 1}} {

    set t1 [clock milliseconds]
    # write annotation in the beginning of the sweep
    if {$first && $db_dev != {} && $db_ann != {} } {
      $db_dev cmd "put $db_ann now sweep to $dest A at $rate A/s"
      $db_dev cmd "sync"
    }

    after cancel $rh


    # get device parameters
    set min_i_step [$dev1 cget -min_i_step]
    set max_i [$dev1 cget -max_i]
    set min_i [$dev1 cget -min_i]
    if {$dev2 != {}} {
      set min_i_step2 [$dev2 cget -min_i_step]
      set max_i2 [$dev2 cget -max_i]
      set min_i2 [$dev2 cget -min_i]
    } else {
      set min_i_step2 1
      set max_i2 0
      set min_i2 0
    }


    # limit rate and destination
    if {$dest > $max_i + $max_i2} {set dest [expr {$max_i+$max_i2}]}
    if {$dest < $min_i + $min_i2} {set dest [expr {$min_i+$min_i2}]}
    if {$rate > $max_rate} {set rate $max_rate}


    # put current value in the database
    set cm1 [ $dev1 get_curr ]
    if {$dev2 != {}} { set cm2 [$dev2 get_curr] } else {set cm2 0}
    set cm [expr {$cm1+$cm2}]
    set cs [expr {$cs1+$cs2}]

    if { $db_dev != {} && $db_val != {}} {
      $db_dev cmd "put $db_val now $cm $cs [get_volt]"
      $db_dev cmd "sync"
    }


    # find sweep direction
    if {$cs < $dest} {set dir 1} else {set dir -1}


    # time step for fast/slow sweeps:
    if { $rate > [expr {$min_i_step/$min_t_step}] } {
      set dt $min_t_step
    } else {
      set dt [expr {$min_i_step/$rate}]
      if {$dt < $min_t_step} {set dt $min_t_step}
    }
    # set current step
    set di [expr {1.0*$dir*$rate*$dt}]


    # same for second channel
    if { $rate > [expr {$min_i_step2/$min_t_step}] } {
      set dt2 $min_t_step
    } else {
      set dt2 [expr {$min_i_step2/$rate}]
      if {$dt < $min_t_step} {set dt $min_t_step}
    }
    # set current step
    set di2 [expr {1.0*$dir*$rate*$dt}]


    # find channel we want to sweep
    set ch 1
    if {$dev2 != {} &&\
       (($dir==1  && $cs2 < $max_i2) ||\
        ($dir==-1 && $cs2 > $min_i2)) } {
      set ch 2
      set dt $dt2
      set di $di2

      # make shorter step if we are close to ch2 limit
      if {$dir==1  && $cs2+$di > $max_i2} {
        set di [expr {$max_i2-$cs2}]
        set dt [expr {1.0*$dir*$di/$rate}]
      }
      if {$dir==-1 && $cs2+$di < $min_i2} {
        set di [expr {-($cs2-$min_i2)}]
        set dt [expr {1.0*$dir*$di/$rate}]
      }
    }

    # stop ramping if the real current jumped outside the tolerance
    set tolerance  [expr 100*$min_i_step]
    set tolerance2 [expr 100*$min_i_step2]
    if { abs($cm1-$cs1) > $tolerance ||\
         abs($cm2-$cs2) > $tolerance2} {
      set cs1 $cm1
      set cs2 $cm2
      if { $db_dev != {} && $db_ann != {}} {
        $db_dev cmd "put $db_ann now current jump to $cm"
        $db_dev cmd "sync"
      }
      return
    }


    # stop ramping if we are near the destination
    if { [expr {abs($cs-$dest)}] < [expr {abs($di)}] } {
      set_curr $ch $dest

      # normal delay between current setting and measurement
      set t2 [clock milliseconds]
      set dt_ms [expr {round(1000*$dt) - ($t2-$t1)}]
      if {$dt_ms <0 } {set dt_ms 0}
      after $dt_ms

      set cm1 [ $dev1 get_curr ]
      if {$dev2 != {}} { set cm2 [$dev2 get_curr] } else {set cm2 0}
      set cm [expr {$cm1 + $cm2}]
      set cs [expr {$cs1 + $cs2}]

      if { $db_dev != {} && $db_val != {}} {
        $db_dev cmd "put $db_val now $cm $cs [get_volt]"
        $db_dev cmd "sync"
      }
      if { $db_dev != {} && $db_ann != {}} {
        $db_dev cmd "put $db_ann now sweep finished at $cs"
        $db_dev cmd "sync"
      }
      return
    }

    # change the current
    set_curr $ch [expr {$cs + 1.0*$dir*$rate*$dt}]

    # calculate time step in ms and set up ramping loop
    set t2 [clock milliseconds]
    set dt_ms [expr {round(1000*$dt) - ($t2-$t1)}]
    if {$dt_ms <0 } {set dt_ms 0}

    set rh [after $dt_ms "$this sweep $dest $rate 0"]
    return
  }
}


#############################################################

spp_server::run SweepController $argv
