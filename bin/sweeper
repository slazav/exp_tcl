#!/usr/bin/tclsh

# current sweeper with stdin/stdout interface

package require Device 1.2
package require ParseOptions 2.0
#package require Tclx

#############################################################
## Command line options:
set options [list \
{-p -ps_dev}   ps_dev   {test}   {power supply device}\
{-d -db_dev}   db_dev   {}       {database device (can be empty)}\
{-n -db_val}   db_val   {}       {database name for numerical values}\
{-a -db_ann}   db_ann   {}       {database name for annatations}\
{-o -volt}     volt     {1}      {set voltage, V}\
{-o -ovp}      ovp      {1}      {set over-voltage protection }\
]

#############################################################
## CurrentSupplyDevice - Device which knows, how to set current

itcl::class CurrentSupplyDevice {
  variable dev;  # device implementation handler
  variable rh;   # ramping loop handler
  variable curr; # current
  public variable min_t_step;  # min time step, s
  public variable min_i_step;  # min current step, A
  public variable max_rate;    # max rate, A/s
  public variable max_i;       # max current, A
  public variable min_i;       # min current, A
  public variable tolerance;   # how large can be difference between
                               # set and measured current, A

  constructor {} {
    global ps_dev
    set rh {}
    set model [$ps_dev get_model]
    set dev [current_supply_devices::$model #auto $this]
    reset
  }
  method set_curr {val} { $dev set_curr $val }
  method get_curr {}    { return [ $dev get_curr ]}
  method get_volt {}    { return [ $dev get_volt ]}

  # Return list of commands which can be run from stdin.
  method help {} {return {help sweep sweep_stop reset get_curr get_volt} }

  ######################################
  # stop sweep and reset device
  method reset {} {
    global db_dev db_val db_ann
    if { $db_dev != {} && $db_val != {} } {
      $db_dev cmd "put $db_ann now reset"
      $db_dev cmd "sync"
    }
    after cancel $rh
    set $rh {}
    $dev reset
    set curr [get_curr]
    return
  }

  ######################################
  # stop sweep and reset device
  method sweep_stop {} {
    global db_dev db_val db_ann
    if {$rh != {} && $db_dev != {} && $db_val != {} } {
      $db_dev cmd "put $db_ann now sweep_stop"
      $db_dev cmd "sync"
    }
    after cancel $rh
    return
  }

  ######################################
  method sweep {dest rate {first 1}} {
    global db_dev db_val db_ann

    # write annotation in the beginning of the sweep
    if {$first && $db_dev != {} && $db_val != {} } {
      $db_dev cmd "put $db_ann now sweep to $dest A at $rate A/s"
      $db_dev cmd "sync"
    }

    after cancel $rh

    if {$dest > $max_i} {set dest $max_i}
    if {$dest < $min_i} {set dest $min_i}
    if {$rate > $max_rate} {set rate $max_rate}


    # put current value in the database
    set curr_meas [get_curr]
    if { $db_dev != {} && $db_val != {}} {
      $db_dev cmd "put $db_val now $curr_meas $curr [get_volt]"
      $db_dev cmd "sync"
    }

    if {$curr < $dest} {set dir 1} else {set dir -1}

    # time step for fast/slow sweeps:
    if { $rate > [expr {$min_i_step/$min_t_step}] } {
      set dt $min_t_step
    } else {
      set dt [expr {$min_i_step/$rate}]
    }
    # set current step
    set di [expr {1.0*$dir*$rate*$dt}]


    # stop ramping if the real current is outside the tolerance
    if { [expr {abs($curr_meas-$curr)}] > $tolerance } {
      set curr $curr_meas
      if { $db_dev != {} && $db_ann != {}} {
        $db_dev cmd "put $db_ann now current jump to $curr"
        $db_dev cmd "sync"
      }
      return
    }

    # calculate time step in ms (1 ms - limit) and set up ramping loop
    set dt_ms [expr {round(1000*$dt)}]
    if {$dt_ms < 1} {set dt_ms 1}

    # stop ramping if we are near the destination
    if { [expr {abs($curr-$dest)}] < [expr {abs($di)}] } {
      set_curr $dest
      # normal delay between current setting and measurement
      after $dt_ms
      set curr [get_curr]
      if { $db_dev != {} && $db_val != {}} {
        $db_dev cmd "put $db_val now $curr $dest [get_volt]"
        $db_dev cmd "sync"
      }
      if { $db_dev != {} && $db_ann != {}} {
        $db_dev cmd "put $db_ann now sweep finished at $curr"
        $db_dev cmd "sync"
      }
      return
    }

    # change the current
    set curr [expr {$curr + 1.0*$dir*$rate*$dt}]
    set_curr $curr

    set rh [after $dt_ms "$this sweep $dest $rate 0"]
    return
  }
}

#############################################################
## device implementations:
namespace eval current_supply_devices {

  ######################################
  # test device
  itcl::class test {
    variable cur; # current
    variable R;   # resistance

    constructor {int_class} {
      $int_class configure -min_t_step 0.5
      $int_class configure -min_i_step 0.01
      $int_class configure -max_rate 0.1
      $int_class configure -max_i 10
      $int_class configure -min_i -10
      set cur 0
      set R 0.1
    }
    method set_curr {val} {set cur $val}
    method get_curr {} {return $cur}
    method get_volt {} {return [expr {$cur*$R}] }
    method reset {} {}
  }
  ######################################
  # Tenma 72-2550
  itcl::class tenma_72-2550 {

    ## set device parameters and reset device
    constructor {int_class} {
      $int_class configure -min_t_step 0.2
      $int_class configure -min_i_step 0.001
      $int_class configure -max_rate 1
      $int_class configure -max_i 3.09
      $int_class configure -min_i 0
      $int_class configure -tolerance 0.03
    }

    method reset {} {
      global ps_dev ovp volt
      ## set voltage if needed
      if { $volt > 0 } {
        set volt [expr {round($volt*100)/100.0}]
        $ps_dev cmd "VSET1:$volt"
      }
      ## set OVP if needed
      if { $ovp != {} && $ovp != 0 } {
        $ps_dev cmd "OVP1"
      } else {
        $ps_dev cmd "OVP0"
      }
      ## set current to actual current, turn output on
      set status [$ps_dev cmd "STATUS?"]
      set c [$ps_dev cmd "IOUT1?"]
      $ps_dev cmd "ISET1:$c"
      $ps_dev cmd "OUT1"
    }

    method set_curr {val} {
      global ps_dev
      set val [expr {round($val*1000)/1000.0}]
      $ps_dev cmd "ISET1:$val"
    }
    method get_curr {} {
      global ps_dev
      return [$ps_dev cmd "IOUT1?"]
    }
    method get_volt {} {
      global ps_dev
      return [$ps_dev cmd "VOUT1?"]
    }
  }

}

#############################################################

# Parse options.
if {[catch {parse_options "sweeper" \
  $argv $options} err]} { error "Error: $err"}

# Check options.
# We need non-empty ps_dev.
if {$ps_dev  == {} } { error "Error: -ps_dev option is empty" }
Device $ps_dev
#$ps_dev lock
#signal trap {SIGTERM SIGHUP} {$ps_dev unlock; exit}

# Open devices.
if {$db_dev != {} } { Device $db_dev }
set dev [CurrentSupplyDevice #auto]


proc read_cmd {dev} {
  global ps_dev
  gets stdin line

  if { [eof stdin] } {
#    $ps_dev unlock
    exit
  }
  if {$line == {}} {continue}
  set cmd [lindex $line 0]
  if {[catch {
    if {$cmd in [$dev help]} { puts "[$dev {*}$line]\nOK" }\
      else {puts "Error: unknown command: $line"}
    }]} {
    puts "Error: bad command: $line"
  }
}

# main loop: read stdin, process commands, send answers
fconfigure stdin -buffering line
fileevent stdin readable "read_cmd $dev"
vwait forever


