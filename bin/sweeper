#!/usr/bin/tclsh

# current sweeper with stdin/stdout interface

lappend auto_path ..
package require Device 1.2
package require ParseOptions 2.0

#############################################################
## Command line options:
set options [list \
{-p -ps_dev}   ps_dev   {test}   {power supply device}\
{-d -db_dev}   db_dev   {}       {database device (can be empty)}\
{-n -db_val}   db_val   {}       {database name for numerical values}\
{-a -db_ann}   db_ann   {}       {database name for annatations}\
{-o -volt}     volt     {1}      {set voltage, V}\
{-o -ovp}      ovp      {1}      {set over-voltage protection }\
]

#############################################################
## CurrentSupplyDevice - Device which knows, how to set current

itcl::class CurrentSupplyDevice {
  variable dev;  # device implementation handler
  variable rh;   # ramping loop handler
  public variable min_t_step;  # min time step, s
  public variable min_i_step;  # min current step, A
  public variable max_rate;    # max rate, A/s
  public variable max_i;       # max current, A
  public variable min_i;       # min current, A

  constructor {} {
    global ps_dev
    set rh {}
    set model [$ps_dev get_model]
    set dev [current_supply_devices::$model #auto $this]
  }
  method set_curr {val} { $dev set_curr $val }
  method get_curr {}    { return [ $dev get_curr ]}
  method get_volt {}    { return [ $dev get_volt ]}

  # Return list of commands which can be run from stdin.
  method help {} {return {help sweep sweep_stop reset get_curr get_volt} }

  # stop sweep and reset device
  method reset {} {
    after cancel $rh
    $dev reset
    return {OK}
  }

  # stop sweep and reset device
  method sweep_stop {} {
    after cancel $rh
    return {OK}
  }

  method sweep {dest rate} {
    global db_dev db_val db_ann
    after cancel $rh

    if {$dest > $max_i} {set dest $max_i}
    if {$dest < $min_i} {set dest $min_i}
    if {$rate > $max_rate} {set rate $max_rate}

    set curr [get_curr]
    if { $db_dev != {} && $db_val != {}} {
      $db_dev cmd "put $db_val now $curr [get_volt]"
      $db_dev cmd "sync"
    }

    if {$curr < $dest} {set dir 1} else {set dir -1}

    # time step for fast/slow sweeps:
    if { $rate > [expr {$min_i_step/$min_t_step}] } {
      set dt $min_t_step
    } else {
      set dt [expr {$min_i_step/$rate}]
    }
    # set current step
    set di [expr {1.0*$dir*$rate*$dt}]

    # stop ramping if we are near the destination
    if { [expr {abs($curr-$dest)}] < $di } {
      set_curr $dest
      set curr [get_curr]
      if { $db_dev != {} && $db_val != {}} {
        $db_dev cmd "put $db_val now $curr [get_volt]"
        $db_dev cmd "sync"
      }
      if { $db_dev != {} && $db_ann != {}} {
        $db_dev cmd "put $db_ann now stop sweep at $curr"
        $db_dev cmd "sync"
      }
      return
    }

    set_curr  [expr {$curr + 1.0*$dir*$rate*$dt}]

    # calculate time step in ms (1 ms - limit) and set up ramping loop
    set dt_ms [expr {round(1000*$dt)}]
    if {$dt_ms < 1} {set dt_ms 1}
    set rh [after $dt_ms "$this sweep $dest $rate"]
    return {OK}
  }
}

#############################################################
## device implementations:
namespace eval current_supply_devices {

  # test device
  itcl::class test {
    variable cur; # current
    variable R;   # resistance

    constructor {int_class} {
      $int_class configure -min_t_step 0.5
      $int_class configure -min_i_step 0.01
      $int_class configure -max_rate 0.1
      $int_class configure -max_i 10
      $int_class configure -min_i -10
      set cur 0
      set R 0.1
    }
    method set_curr {val} {set cur $val}
    method get_curr {} {return $cur}
    method get_volt {} {return [expr {$cur*$R}] }
    method reset {} {}
  }

  # Tenma 72-2550
  itcl::class tenma_72-2550 {

    ## set device parameters and reset device
    constructor {int_class} {
      $int_class configure -min_t_step 0.2
      $int_class configure -min_i_step 0.001
      $int_class configure -max_rate 1
      $int_class configure -max_i 3.09
      $int_class configure -min_i 0
      reset
    }

    method reset {} {
      global ps_dev ovp volt
      ## set voltage if needed
      if { $volt > 0 } {
        set val [expr {round($ovp*100)/100.0}]
        $ps_dev cmd "VSET1:$ovp"
      }
      ## set OVP if needed
      if { $ovp != {} && $ovp != 0 } {
        $ps_dev cmd "OVP1"
      } else {
        $ps_dev cmd "OVP0"
      }
      ## set current to actual current, turn output on
      set status [$ps_dev cmd "STATUS?"]
      set c [$ps_dev cmd "IOUT1?"]
      $ps_dev cmd "ISET1:$c"
      $ps_dev cmd "OUT1"
    }

    method set_curr {val} {
      global ps_dev
      set val [expr {round($val*1000)/1000.0}]
      $ps_dev cmd "ISET1:$val"
    }
    method get_curr {} {
      global ps_dev
      return [$ps_dev cmd "IOUT1?"]
    }
    method get_volt {} {
      global ps_dev
      return [$ps_dev cmd "VOUT1?"]
    }
  }

}

#############################################################

# Parse options.
if {[catch {parse_options "sweeper" \
  $argv $options} err]} { error "Error: $err"}

# Check options.
# We need non-empty ps_dev.
if {$ps_dev  == {} } { error "Error: -ps_dev option is empty" }
Device $ps_dev

# Open devices.
if {$db_dev != {} } { Device $db_dev }
set dev [CurrentSupplyDevice #auto]

proc read_cmd {dev} {
  gets stdin line
  set cmd [lindex $line 0]
  if {$cmd in [$dev help]} { puts [$dev {*}$line] }
  if { [eof stdin] } {exit}
}

# main loop: read stdin, process commands, send answers
fconfigure stdin -buffering line
fileevent stdin readable "read_cmd $dev"
vwait forever


